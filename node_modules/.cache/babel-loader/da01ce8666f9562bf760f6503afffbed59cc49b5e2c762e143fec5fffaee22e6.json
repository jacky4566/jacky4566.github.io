{"ast":null,"code":"import { CELL_SIZE } from \"../helpers/consts\";\nimport { DIRECTION_RIGHT, DIRECTION_LEFT, DIRECTION_UP, DIRECTION_DOWN } from \"../helpers/consts\";\nconst CAMERA_SPEED = 0.02;\nconst CAMERA_LOOKAHEAD = 3;\nconst USE_SMOOTH_CAMERA = true;\nexport class Camera {\n  constructor(level) {\n    this.level = level;\n    const [heroX, heroY] = this.level.heroRef.displayXY();\n    this.cameraX = heroX;\n    this.cameraY = heroY;\n    this.pixelSize = getComputedStyle(document.documentElement).getPropertyValue('--pixel-size');\n    const cameraLefttile = Math.max(0, Math.floor((cameraXY[0] - window.innerWidth / 2 / pixelSize) / CELL_SIZE));\n    const cameraRighttile = Math.min(widthWithWalls, Math.ceil((cameraXY[0] + window.innerWidth / 2 / pixelSize) / CELL_SIZE) + 2);\n    const cameraTopttile = Math.max(0, Math.floor((cameraXY[1] - window.innerHeight / 2 / pixelSize) / CELL_SIZE));\n    const cameraBottomttile = Math.min(heightWithWalls, Math.ceil((cameraXY[1] + window.innerHeight / 2 / pixelSize) / CELL_SIZE) + 2);\n    this.transformOffsetX = -5.5 * CELL_SIZE;\n    this.transformOffsetY = -5.5 * CELL_SIZE;\n  }\n  get transform() {\n    return [this.cameraX, this.cameraY, this.transformOffsetX, this.transformOffsetY];\n  }\n  static lerp(currentValue, destinationValue, time) {\n    return currentValue * (1 - time) + destinationValue * time;\n  }\n  tick() {\n    // Start where the Hero is now\n    const hero = this.level.heroRef;\n    const [heroX, heroY] = hero.displayXY();\n    let cameraDestinationX = heroX;\n    let cameraDestinationY = heroY;\n\n    //If moving, put the camera slightly ahead of where Hero is going\n    if (hero.movingPixelsRemaining > 0) {\n      if (hero.movingPixelDirection === DIRECTION_DOWN) {\n        cameraDestinationY += CAMERA_LOOKAHEAD * CELL_SIZE;\n      } else if (hero.movingPixelDirection === DIRECTION_UP) {\n        cameraDestinationY -= CAMERA_LOOKAHEAD * CELL_SIZE;\n      } else if (hero.movingPixelDirection === DIRECTION_LEFT) {\n        cameraDestinationX -= CAMERA_LOOKAHEAD * CELL_SIZE;\n      } else if (hero.movingPixelDirection === DIRECTION_RIGHT) {\n        cameraDestinationX += CAMERA_LOOKAHEAD * CELL_SIZE;\n      }\n    }\n    if (USE_SMOOTH_CAMERA) {\n      this.cameraX = Camera.lerp(this.cameraX, cameraDestinationX, CAMERA_SPEED);\n      this.cameraY = Camera.lerp(this.cameraY, cameraDestinationY, CAMERA_SPEED);\n    } else {\n      this.cameraX = cameraDestinationX;\n      this.cameraY = cameraDestinationY;\n    }\n  }\n}","map":{"version":3,"names":["CELL_SIZE","DIRECTION_RIGHT","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_DOWN","CAMERA_SPEED","CAMERA_LOOKAHEAD","USE_SMOOTH_CAMERA","Camera","constructor","level","heroX","heroY","heroRef","displayXY","cameraX","cameraY","pixelSize","getComputedStyle","document","documentElement","getPropertyValue","cameraLefttile","Math","max","floor","cameraXY","window","innerWidth","cameraRighttile","min","widthWithWalls","ceil","cameraTopttile","innerHeight","cameraBottomttile","heightWithWalls","transformOffsetX","transformOffsetY","transform","lerp","currentValue","destinationValue","time","tick","hero","cameraDestinationX","cameraDestinationY","movingPixelsRemaining","movingPixelDirection"],"sources":["C:/GitHub/AthabascaCPSCI/COMP 486/Mineral Mayhem/src/classes/Camera.js"],"sourcesContent":["import { CELL_SIZE } from \"../helpers/consts\";\r\nimport {\r\n  DIRECTION_RIGHT,\r\n  DIRECTION_LEFT,\r\n  DIRECTION_UP,\r\n  DIRECTION_DOWN,\r\n} from \"../helpers/consts\";\r\n\r\nconst CAMERA_SPEED = 0.02;\r\nconst CAMERA_LOOKAHEAD = 3;\r\nconst USE_SMOOTH_CAMERA = true;\r\n\r\nexport class Camera {\r\n  constructor(level) {\r\n    this.level = level;\r\n    const [heroX, heroY] = this.level.heroRef.displayXY();\r\n    this.cameraX = heroX;\r\n    this.cameraY = heroY;\r\n    this.pixelSize = getComputedStyle(document.documentElement).getPropertyValue('--pixel-size');\r\n    const cameraLefttile = Math.max(0, Math.floor((cameraXY[0] - (window.innerWidth / 2 / pixelSize)) / CELL_SIZE));\r\n    const cameraRighttile = Math.min(widthWithWalls, Math.ceil((cameraXY[0] + (window.innerWidth / 2 / pixelSize)) / CELL_SIZE) + 2);\r\n    const cameraTopttile = Math.max(0, Math.floor((cameraXY[1] - (window.innerHeight / 2 / pixelSize)) / CELL_SIZE));\r\n    const cameraBottomttile = Math.min(heightWithWalls, Math.ceil((cameraXY[1] + (window.innerHeight / 2 / pixelSize)) / CELL_SIZE) + 2);\r\n\r\n    this.transformOffsetX = -5.5 * CELL_SIZE;\r\n    this.transformOffsetY = -5.5 * CELL_SIZE;\r\n    }\r\n\r\n  get transform() {\r\n    return [this.cameraX, this.cameraY, this.transformOffsetX, this.transformOffsetY]\r\n  }\r\n\r\n  static lerp(currentValue, destinationValue, time) {\r\n    return currentValue * (1 - time) + destinationValue * time;\r\n  }\r\n\r\n  tick() {\r\n    // Start where the Hero is now\r\n    const hero = this.level.heroRef;\r\n    const [heroX, heroY] = hero.displayXY();\r\n    let cameraDestinationX = heroX;\r\n    let cameraDestinationY = heroY;\r\n\r\n    //If moving, put the camera slightly ahead of where Hero is going\r\n    if (hero.movingPixelsRemaining > 0) {\r\n      if (hero.movingPixelDirection === DIRECTION_DOWN) {\r\n        cameraDestinationY += CAMERA_LOOKAHEAD * CELL_SIZE;\r\n      } else if (hero.movingPixelDirection === DIRECTION_UP) {\r\n        cameraDestinationY -= CAMERA_LOOKAHEAD * CELL_SIZE;\r\n      } else if (hero.movingPixelDirection === DIRECTION_LEFT) {\r\n        cameraDestinationX -= CAMERA_LOOKAHEAD * CELL_SIZE;\r\n      } else if (hero.movingPixelDirection === DIRECTION_RIGHT) {\r\n        cameraDestinationX += CAMERA_LOOKAHEAD * CELL_SIZE;\r\n      }\r\n    }\r\n\r\n    if (USE_SMOOTH_CAMERA) {\r\n      this.cameraX = Camera.lerp(\r\n        this.cameraX,\r\n        cameraDestinationX,\r\n        CAMERA_SPEED\r\n      );\r\n      this.cameraY = Camera.lerp(\r\n        this.cameraY,\r\n        cameraDestinationY,\r\n        CAMERA_SPEED\r\n      );\r\n    } else {\r\n      this.cameraX = cameraDestinationX;\r\n      this.cameraY = cameraDestinationY;\r\n    }\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}